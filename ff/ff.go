package ff

type FF struct {
	M     int
	Basis []uint16
}

func (ff2 *FF) New(m int) {
	ff2.M = m
	basis := make([]uint16, m)
	for i := 0; i < m; i++ {
		basis[m-i-1] = 1 << i
	}
	ff2.Basis = basis
}

func (ff2 *FF) Add(a, b uint16) uint16 {
	return a ^ b
}

func (ff2 *FF) Mul(a, b uint16) uint16 {
	var buf uint32

	buf = uint32(a * (b & 1))
	buf ^= uint32(a * (b & 0x0002))
	buf ^= uint32(a * (b & 0x0004))
	buf ^= uint32(a * (b & 0x0008))
	buf ^= uint32(a * (b & 0x0010))
	buf ^= uint32(a * (b & 0x0020))
	buf ^= uint32(a * (b & 0x0040))
	buf ^= uint32(a * (b & 0x0080))
	buf ^= uint32(a * (b & 0x0100))
	buf ^= uint32(a * (b & 0x0200))
	buf ^= uint32(a * (b & 0x0400))
	buf ^= uint32(a * (b & 0x0800))

	return reduce(buf)
}

func (ff2 *FF) Sqr(a uint16) uint16 {
	buf := uint32(a)
	buf = (buf | (buf << 8)) & 0x00FF00FF
	buf = (buf | (buf << 4)) & 0x0F0F0F0F
	buf = (buf | (buf << 2)) & 0x33333333
	buf = (buf | (buf << 1)) & 0x55555555

	return reduce(buf)
}

func (ff2 *FF) Inv(a uint16) uint16 {
	var a3, a15, b uint16

	a3 = ff2.Sqr(a)     /* a^2 */
	a3 = ff2.Mul(a3, a) /* a^3 */

	a15 = ff2.Sqr(a3)      /* a^6 */
	a15 = ff2.Sqr(a15)     /* a^12 */
	a15 = ff2.Mul(a15, a3) /* a^15 */

	b = ff2.Sqr(a15)    /* a^30 */
	b = ff2.Sqr(b)      /* a^60 */
	b = ff2.Sqr(b)      /* a^120 */
	b = ff2.Sqr(b)      /* a^240 */
	b = ff2.Mul(b, a15) /* a^255 */

	b = ff2.Sqr(b)     /* a^510 */
	b = ff2.Sqr(b)     /* a^1020 */
	b = ff2.Mul(b, a3) /* a^1023 */

	b = ff2.Sqr(b)    /* a^2046 */
	b = ff2.Mul(b, a) /* a^2047 */

	return ff2.Sqr(b) /* a^4094 */
}

/* GF(2^12), generated by f(x) = x^12 + x^3 + 1 */
func reduce(a uint32) uint16 {
	var buf uint32

	buf = a & 0x7F0000
	a ^= buf >> 9
	a ^= buf >> 12

	buf = a & 0x00F000
	a ^= buf >> 9
	a ^= buf >> 12

	return uint16(a & 0xFFF)
}

// Check the validity of Goppa polynomial
// 1 - g0 != 0
// 2 - Goppa polynomial  has no roots in F{2^m}. Check by Additive FFT
// 3 - Goppa polynomial  has no repeated roots in any extension ô°€field.  Check by GCD(G)
func (ff2 *FF) CheckGoppaPoly(g []uint16) bool {

	if g[0] == 0 {
		return false
	}
	if !ff2.checkFft(g) {
		return false
	}

	// if (formal_derivative_poly(Gz, Dz)) {
	// 	if (gcd_poly(ff2m, Gz, Dz, Fz)) {
	// 		status = (Fz->degree < 1);
	// 	}
	// }

	return true
}

// Return true, if Goppa polynomial  has roots in  F{2^m}
func (ff2 *FF) checkFft(pol []uint16) bool {
	w := ff2.AdaptiveFft(pol)

	for i := 0; i < ff2.M; i++ {
		if w[i] == 0 {
			return false
		}
	}
	return true
}

func (ff2 *FF) AdaptiveFft(G []uint16) []uint16 {

	return nil
}

func TaylorExpansion() {

}
