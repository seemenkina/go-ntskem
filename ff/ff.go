package ff

import (
	"github.com/seemenkina/go-ntskem/poly"
)

type FF struct {
	M     int
	Basis []uint16
}

func (ff2 *FF) New(m int) {
	ff2.M = m
	basis := make([]uint16, m)
	for i := 0; i < m; i++ {
		basis[m-i-1] = 1 << i
	}
	ff2.Basis = basis
}

func (ff2 *FF) Add(a, b uint16) uint16 {
	return a ^ b
}

func (ff2 *FF) Mul(a, b uint16) uint16 {
	var buf uint32

	buf = uint32(a * (b & 1))
	buf ^= uint32(a * (b & 0x0002))
	buf ^= uint32(a * (b & 0x0004))
	buf ^= uint32(a * (b & 0x0008))
	buf ^= uint32(a * (b & 0x0010))
	buf ^= uint32(a * (b & 0x0020))
	buf ^= uint32(a * (b & 0x0040))
	buf ^= uint32(a * (b & 0x0080))
	buf ^= uint32(a * (b & 0x0100))
	buf ^= uint32(a * (b & 0x0200))
	buf ^= uint32(a * (b & 0x0400))
	buf ^= uint32(a * (b & 0x0800))

	return reduce(buf)
}

func (ff2 *FF) Sqr(a uint16) uint16 {
	buf := uint32(a)
	buf = (buf | (buf << 8)) & 0x00FF00FF
	buf = (buf | (buf << 4)) & 0x0F0F0F0F
	buf = (buf | (buf << 2)) & 0x33333333
	buf = (buf | (buf << 1)) & 0x55555555

	return reduce(buf)
}

func (ff2 *FF) Inv(a uint16) uint16 {
	var a3, a15, b uint16

	a3 = ff2.Sqr(a)     /* a^2 */
	a3 = ff2.Mul(a3, a) /* a^3 */

	a15 = ff2.Sqr(a3)      /* a^6 */
	a15 = ff2.Sqr(a15)     /* a^12 */
	a15 = ff2.Mul(a15, a3) /* a^15 */

	b = ff2.Sqr(a15)    /* a^30 */
	b = ff2.Sqr(b)      /* a^60 */
	b = ff2.Sqr(b)      /* a^120 */
	b = ff2.Sqr(b)      /* a^240 */
	b = ff2.Mul(b, a15) /* a^255 */

	b = ff2.Sqr(b)     /* a^510 */
	b = ff2.Sqr(b)     /* a^1020 */
	b = ff2.Mul(b, a3) /* a^1023 */

	b = ff2.Sqr(b)    /* a^2046 */
	b = ff2.Mul(b, a) /* a^2047 */

	return ff2.Sqr(b) /* a^4094 */
}

/* GF(2^12), generated by f(x) = x^12 + x^3 + 1 */
func reduce(a uint32) uint16 {
	var buf uint32

	buf = a & 0x7F0000
	a ^= buf >> 9
	a ^= buf >> 12

	buf = a & 0x00F000
	a ^= buf >> 9
	a ^= buf >> 12

	return uint16(a & 0xFFF)
}

// Check the validity of Goppa polynomial
// 1 - g0 != 0
// 2 - Goppa polynomial  has no roots in F{2^m}. Check by Additive FFT
// 3 - Goppa polynomial  has no repeated roots in any extension Ùè∞Äfield.  Check by GCD(G)
func (ff2 *FF) CheckGoppaPoly(g *poly.Polynomial) bool {

	if g.Pol[0] == 0 {
		return false
	}
	if ff2.HasRoots(g) {
		return false
	}

	dx := ff2.Derivative(g)
	if dx != nil {
		gcd := ff2.GCD(g, dx)
		if gcd == nil || gcd.GetDegree() < 1 {
			return false
		}
	}

	return true
}

func (ff2 *FF) Derivative(g *poly.Polynomial) *poly.Polynomial {
	dx := poly.Polynomial{}
	dx.New(1 << ff2.M)

	if dx.Size() < g.Size()-1 {
		return nil
	}

	for i := 0; i < g.GetDegree(); i++ {
		dx.Pol[i] = 0
		if (i & 1) == 0 {
			dx.Pol[i] = g.Pol[i+1]
		}
	}
	dx.SetDegree(g.GetDegree() - 1)
	for i := 0; i < g.GetDegree(); i++ {
		if dx.Pol[g.GetDegree()-i-1] == 0 {
			dx.SetDegree(dx.GetDegree() - 1)
			break
		}
		dx.SetDegree(dx.GetDegree() - 1)
	}
	return &dx
}

func (ff2 *FF) GCD(f, g *poly.Polynomial) *poly.Polynomial {
	if f.GetDegree() < 1 {
		return g
	}

	if g.GetDegree() < 1 {
		return f
	}

	if g.GetDegree() < f.GetDegree() {
		g, f = f, g
	}

	return ff2.GCD(f, ff2.ModuloReduce(g, f))
}

func (ff2 *FF) ModuloReduce(pol, mod *poly.Polynomial) *poly.Polynomial {
	for pol.GetDegree() >= mod.GetDegree() {
		a := ff2.Mul(pol.Pol[pol.GetDegree()], ff2.Inv(mod.Pol[mod.GetDegree()]))
		j := pol.GetDegree() - mod.GetDegree()
		for i := 0; i < mod.GetDegree(); i, j = i+1, j+1 {
			if mod.Pol[i] != 0 {
				pol.Pol[j] = ff2.Add(pol.Pol[j], ff2.Mul(mod.Pol[i], a))
			}
		}
		pol.Pol[j] = 0
		for pol.GetDegree() >= 0 && (pol.Pol[pol.GetDegree()] != 0) {
			pol.SetDegree(pol.GetDegree() - 1)
		}
	}

	return pol
}

// Return true, if Goppa polynomial  has roots in  F{2^m}
func (ff2 *FF) HasRoots(pol *poly.Polynomial) bool {
	for i := 0; i < 1<<ff2.M; i++ {
		roots := ff2.PolynomialInPointer(pol, uint16(i))
		if roots == 0 {
			return true
		}
	}
	return false
}

func (ff2 *FF) Roots(pol *poly.Polynomial) []uint16 {
	roots := make([]uint16, 1<<ff2.M)
	for i := 0; i < 1<<ff2.M; i++ {
		point := ff2.CalculatePoint(uint16(i))
		roots[i] = ff2.PolynomialInPointer(pol, point)
	}
	return roots
}
func (ff2 *FF) CalculatePoint(b uint16) uint16 {
	point := b & (1 << ff2.M)
	for i := 0; i < ff2.M-1; i++ {
		point = ff2.Add(point, ff2.Mul(b&1, ff2.Basis[i]))
		b = b >> 1
	}
	return point
}

func (ff2 *FF) PolynomialInPointer(pol *poly.Polynomial, point uint16) uint16 {
	if point == 0 {
		return pol.Pol[0]
	}

	x := point
	y := pol.Pol[0]
	for i := 1; i <= pol.GetDegree(); i++ {
		y = ff2.Add(y, ff2.Mul(x, pol.Pol[i]))
		x = ff2.Mul(x, point)
	}
	return y
}

func (ff2 *FF) Pow(x, pow uint16) uint16 {
	result := uint16(1)
	for i := uint16(0); i < pow; i++ {
		result = ff2.Mul(result, x)
	}
	return result
}

func (ff2 *FF) BerlekampMasseyAlgorithm(s []uint16) (*poly.Polynomial, uint16) {
	t := len(s) >> 1
	Sigma := make([]uint16, t+1)
	Beta := make([]uint16, t+1)
	fi := make([]uint16, t+1)
	Sigma[0] = 1
	Beta[1] = 1

	var d, delta uint16 = 1, 1
	var L, R uint16 = 0, 0

	for i := 0; i < len(s); i++ {
		for j := 0; j <= t && j < i; j++ {
			d = ff2.Add(d, ff2.Mul(Sigma[j], s[i-j]))
		}
		for j := 0; j <= t; j++ {
			fi[j] = ff2.Add(ff2.Mul(delta, Sigma[j]), ff2.Mul(d, Beta[j]))
		}

		if d == 0 || uint16(i) < (L<<1) {
			R++
			for j := t; j > 0; j-- {
				Beta[j] = Beta[j-1]
			}
		} else {
			R = 0
			L = uint16(i) - L + 1
			delta = d
			for j := t; j > 0; j-- {
				Beta[j] = Sigma[j-1]
			}
		}
		for i := 0; i < t+1; i++ {
			Sigma[i] = fi[i]
		}
	}
	SigmaRec := poly.Polynomial{} // //
	SigmaRec.New(t + 1)
	SigmaRec.SetDegree(t)
	for SigmaRec.GetDegree() > 0 && Sigma[SigmaRec.GetDegree()] == 0 {
		SigmaRec.SetDegree(SigmaRec.GetDegree() - 1)
	}
	var inv = ff2.Inv(Sigma[0])
	for i := 0; i <= SigmaRec.GetDegree(); i++ {
		SigmaRec.Pol[i] = ff2.Mul(Sigma[SigmaRec.GetDegree()-i], inv)
	}
	xi := uint16(0)
	if uint16(SigmaRec.GetDegree()) > (uint16(t) - (R >> 1)) {
		xi = 1
	}
	return &SigmaRec, xi
}
